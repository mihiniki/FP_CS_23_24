###################################################################################################
# Week_01 - Recursion (part 1)
###################################################################################################

[X] If you don't have access to Moodle, write me an email as soon as possible: 5mi0800082@g.fmi.uni-sofia.bg .
[X] Walk around the GitHub page.
[X] Here is a timeline THAT MIGHT CHANGE:
    - homework 1: week 03 (2 programming tasks)
    - homework 2: week 06 (2 programming tasks)
    - exam 1    : week 07 (8 theoretical questions + 4 programming tasks)
    - homework 3: week 11 (2 programming tasks)
    - homework 4: week 14 (2 programming tasks)
    - exam 2    : week 15 (8 theoretical questions + 4 programming tasks)

- !! bracket overflow ðŸ˜„ !!
- Racket is PREFIX, i.e. first write the procedure and then write its arguments
- extension for Racket files: .rkt
- Edit > Preferences > Editing > Racket > put ticks everywhere
- Edit > Preferences > Editing > General Editing > Enable automatic parenthesis, square brackets, and quotes
- Shortcuts
    - `Cntr + Up-arrow` (or `Esc + p`) for using the previous input in interpreter window
    - `F5` (or `Cntr + F5`) for running the code in the text editor window
    - `Enter` to run code in the interpreter with caret after last character
    - `Cntr + Enter` to run code in the interpreter without caret after last character
    - the two windows are independent, so feel free to test code in the interpreter window even if the code in the text editor window has errors or is incomplete
- IMPORTANT NOTE: DrRacket DOES NOT autosave.


Comments
    Only for human-readable text.

    ; This is a single-line comment
    #|
    This
    is
    a multiline comment.
    |#


The functions in Racket are (formally) called procedures
    What is the difference between a procedure and a method?
        The method is part of a class. It has access to *this.


What is a predicate?
    A expression/function/procedure which return true or false.


Types of Evaluation Processes
   Linearly Recursive
        1. The result is stored in a recursive tail.
        2. The recursive call is part of an expression.

   Linearly Iterative
        1. The result is stored as a variable that is set by ANOTHER function.
        Often the variable is named "result" and the function - "helper".
        2. The recursive call is not part of an expression.
        These processes are faster than the linearly recursive ones!


What is a declaration and what is a definition?
    int add(const int x, const int y)       <-- declaration
    {                                       <-- definition
        return x + y;                       <-- definition
    }                                       <-- definition


Built-in data types
    - boolean: #t #f
    - numbers: 1, 1.5, 2+3i
    - strings: "hello"
    - Pairs: '(1 . 2)
    - Lists: '(1 2 3 4 5)
    - conventions for identifiers:
        - myProgram vs. my_program vs. my-program (Kebab Case ðŸ˜„)
        - predicate => suffix "?"


Procedures
    display
        - prints something on console
        - (display "Hello, world!") -> Hello, world!
    = 
        - check equality between numbers
        - (= 5 5) -> #t
        - (= 5 -5) -> #f
    (add1 x), (sub1 x): analogous to (+ x 1) and (- x 1)
    equal?
        - check for equality if arguments are not numbers
        - (equal? "Hello" "He") -> #f
        - (equal? 5 "He") -> #f
    boolean operators: not, and, or
        - (and #t #f) -> #f
        - (not #t) -> #f
    /
        - division between numbers
        - (/ 10 5) -> 2
        - (/ 10.0 7.0) -> 1.4285714285714286
    quotient
        - returns the whole part of the division
        - (quotient 10.0 7.0) -> 1.0
    remainder
        - returns the remainder of the division
        - (remainder 123 10) -> 3
    cond
        - The equivalent of the "switch" case in C++.
        - Used to define guards.
        - Example:
            (define (f x)
				(cond
					[(= x 10) "x is 10"]
					[(even? x) "x is not 10 but is even"]
					[else "x is not 10 and is not even"]
					)
            )

            (f 10) ; -> x is 10
            (f 5) ; -> x is not 10 and is not even
            (f 6) ; -> x is not 10 but is even
    expt
        - the power operator
        - (expt 2 10) -> 1024
    min, max, +, -, *, <, <=, ...
        - NOTE: They work with more than two numbers also!
        - (max 1 2 3 4 5) -> 5
        - (<= 1 2 3 4 5) -> #t
    (if <boolean_cond>  <= Notice the line breaks!
        <code if true>  <= Notice the line breaks!
        <code if false> <= Notice the line breaks!
        )


Key words to watch out for in an exam
    - ÐµÑÑ‚ÐµÑÑ‚Ð²ÐµÐ½Ð¾
    - Ð½ÐµÐ¾Ñ‚Ñ€Ð¸Ñ†Ð°Ñ‚ÐµÐ»Ð½Ð¾
    - Ð½ÐµÐ¿Ð¾Ð»Ð¾Ð¶Ð¸Ñ‚ÐµÐ»Ð½Ð¾
    - Ð¿Ð¾Ð»Ð¾Ð¶Ð¸Ñ‚ÐµÐ»Ð½Ð¾
    - Ð¸Ð½Ð´ÐµÐºÑ
    - ...


Nested procedures
    - Will more than one procedure use it?
        - Yes => global
        - No => nested


The hello world procedure:

#lang racket    <--- Should always be there

(display "Hello, world!")
^                       ^
|                       |
|                       |
Do not forget the parenthesis (procedure <=> parenthesis) !



###################################################################################################
# Week_02 - Recursion (part 2)
###################################################################################################

For home
	WARNING
		Getting a â€œYesâ€ DOES NOT mean getting a bonus.

Importing libraries:
    #import ... (in C++) => (require ...) (in Racket)
	(require math/number-theory) ; API: https://docs.racket-lang.org/math/number-theory.html
	(require racket/trace) ; see what arguments a procedure gets when it is called

Procedures:
	(divides? d n): Whether d divides n with remainder=0.
		(divides? 5 25) -> #t ; How would you implement it? Answer: (zero? (reminder 25 5))
		(divides? 5 19) -> #f
		(divides? 10 66) -> #f
		(divides? 10 100) -> #t
    (divisor-sum n): The sum of the divisors of a number.
        (divisor-sum 6) -> 12 (1 + 2 + 3 + 6)
	(prime? n): Whether n is a prime number.
	(prime-divisors n): Get a list of all the prime divisors of a number.
	(even? n): Whether n is an even number.
	(odd? n): Whether n is an odd number.
	(factorial n): Get the factorial of a number.
	(trace <f-name>): See what calculations happen where. VERY USEFUL FOR DEBUGGING!

###################################################################################################
# Week_03 - Recursion (part 3)
###################################################################################################

[ ] Test 1: 18.11.2023 (Saturday), 12 pm - 4 pm (part 1: 4 programming tasks, part 2: (usually) 8 theoretical questions).
[ ] Test 2: 13.01.2024 (Saturday), 12 pm - 4 pm (part 1: 4 programming tasks, part 2: (usually) 8 theoretical questions).

###################################################################################################
# Week_04 - Lambda Expressions
###################################################################################################

General
	procedures without a name (anonymous)
		called "arrow functions" in JS, TS, etc (Frontend Languages and Frameworks)
		in    Python3 : lambda x : x + 1
		in    C++        : [](const int x) { return x + 1; } (if interested: https://www.youtube.com/watch?v=mWgmBBz0y8c)
		in    Racket     : (Î» (x) (add1 x))
		in    Haskell    : (\ x -> x + 1)

	have four parts
		brackets
		the lambda symbol ; in DrRacket use Cntr + \ or lambda
		sequence of parameters (separated by SPACE)
		a procedure to be executed over those parameters
	    	(Î» (<parameters>) (<procedure>))

	a lambda that adds 5 to a number: 
		how would a test look like? 

	a lambda-predicate that checks whether a number is greater than 10: 
		how would a test look like? 

	a lambda which adds three numbers: 
		how would a test look like? 

	What is an unary procedure? 
		examples: 
	
    What is a binary procedure?
		examples: 

Function Composition
	Composition of f and g over x: 
	We did it last time. Can you tell me which task it was?
        

Partial Application
	1. Take an n-argument procedure f (n > 1).
	2. Apply it to m arguments (m < n).
	3. Return a procedure that takes (n - m) arguments.
	Done! You have just applied f partially to m arguments. The result is a procedure!!
    Currying:
        When you keep applying f only to m=1 arguments until all of them are supplied.

Higher order procedure
	A procedure that accepts at least one procedure as a parameter and/or returns a procedure.
    Procedures can be passed to other procedures just like a normal type (numbers, strings, vectors, arrays, etc.).
        That is why they are called "first class citizens" in JS.

What will the following produce?
	((Î» (x y z) (string-append x y z)) "This" " is " "Racket!")
	((Î» (x y z) (x y z)) (Î» (x y) (+ x y)) 5 6)

Applicative and normal order evaluation
    In applicative order execution, all procedure arguments are evaluated before applying the procedure. In normal order execution, procedure arguments are evaluated after applying the procedure, and then only if the result is needed to complete the evaluation of the procedure.

    What type of evaluation does C++ have? applicative
    What type of evaluation does Racket have? applicative
    What type of evaluation does Haskell have? normal
